Debouncing is a technique where you delay the execution of a function until after a certain amount of time has passed. 
-> This is useful if you have a frequently used function—say, a scroll or resize event listener—and don’t want to trigger it too frequently because that might slow down the browser.

Throttling is a technique in which, no matter how many times the user fires the event, the attached function will be executed only once in a given time interval.
-> Throttling ensures that the function executes at regular intervals.

Callback - A fn that is passed as a parameter to another function.

Ex: 
function add(a,b){
return a+b;
}

function subtract(a,b){
return a-b;
}

function calculate(x,y,operation){
return operation(x,y);
}

console.log(operation(2,3,add));
--------------------------------------------------------------------------------------------------
Promise - Represents an eventual completion/failure of an asynchronous operation. [resolve, reject]

Closure - An inner fn that has access to outer fn's private variables's scope which enables encapsulation.

1st Example : 

for(let i=0; i< 5;i++){
setTimeout(function(){
console.log(i)
},1000)
}
output : 0,1,2,3,4

When you use let, the variable i is block-scoped. This means that each iteration of the loop has its own separate i variable. As a result, each setTimeout callback captures the i value as it is at that iteration.
------------------------------------------
for(var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}

output : 5,5,5,5,5

When you use var, the variable i is function-scoped, not block-scoped. This means that there is only one i variable shared across all iterations of the loop. By the time the setTimeout callbacks are executed (after 1000 milliseconds), the loop has completed and i has the value 5.
----------------------------------------------------------------------------------------------

2nd Example:

function createCounter(){
let count =0;
return function(){
count++;
console.log('Count:',count);
}
}

const counter = createCounter();
counter();
counter();

Output: 1,2
-------------------------------------------------------------------------------------

3rd Example:

function outerFuntion(){
let outerVariable = 'Hi this is outer variable';
	return function innerFunction(){
	console.log(outerVariable)
	}
}

console.log(outerFunciton);
--------------------------------------------------------------------------------------
Copying Array into another array :

-----------------------------------------------------------------------------------------------
console.log(null == 0);// false
console.log(null > 0);// false
console.log(null >= 0);// true
console.log(Number(null));// 0


console.log([43,31] > [89]); // false
console.log([3] > [2]); // true;

Note: in Javascript , it will treat as string, character by character

Merge two arrays and remove duplicates
let a1 = ['a','b', 'c','b'];
let a2 = ['d','e','f'];

let mergedArr = [...a1, ...a2];
let removeDuplicates = [...new Set(mergedArr)];



4. Strict Mode - A mode which introduces better error checking in the code.
5. JS Data Types (string, number, bool, undefined, null) | JS Objects (fn , Array, Prototype)
6. Callback Hell - Phenomenon having heavily nested callbacks
7. JS Errors - Standard Errors (syntax, range, reference, type), System Errors, User Specified Errors, Assertion Errors
8. Hoisting- 
9. Flexbox - layout module in CSS that allows to create flexible and responsive layouts.
10. Authentication (verifying the identity of user/system) | Authorization (granting/denying access to a resource)
11. Increase DB Performance - Indexing, Query Optimization (using query execution plan, avoid wild card characters), 
12. Parameter (placeholder used in declaration of fn)[func add(x,y)]| argument (actual value that is passed to the fn when it is called.)[add(3,5)]
13. Modules - They are basically classes. "require" is used basically to import modules
14. Node JS Archeitecture
15. Null (Explicitly assigned to represent an invalid value)
16. Undefined (Represents the absence of any value)
17. Box Model: Describing the layout of an HTML element. It consists of padding, border, margin of an element.
18. new Set() :  Sets in JavaScript are collections of unique values, meaning no duplicates are allowed.

19. semantic HTML : 
20. semantic HTML tags in HTML5:
21. ngrx explain with working example, forkjoin
22. lazy loading:
23. setImediate vs setTimeout
24. ORM in nosql
25. inner join, outer join
26. return records without duplicate - sql
27. node js - synchronous or asynchronous in nature ?
28. Promise.all , callback , closure, callback hell, event driven approach
29. aws |azure| gcp
30. Synthetic Events : It is an object that serves as a cross browser wrapper of the browser’s native event.
31: How XSS attacks are avoided in React
- Automatic Escaping of Content
JSX Escaping: In React, when you use curly braces {} to insert dynamic content into JSX, React automatically escapes that content. This means any HTML tags or scripts included in the content are treated as plain text rather than executable code.

const userInput = "<script>alert('XSS');</script>";
return <div>{userInput}</div>; // Renders as <div>&lt;script&gt;alert('XSS');&lt;/script&gt;</div>
-----------------------------------------------------------------------------------------------------

32: How you can avoid the need to explicitly use lifecycle hooks like componentDidMount, componentDidUpdate, and componentWillUnmount by using useEffect hook ?.

import { useEffect, useState } from 'react';

function MyComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Effect runs on mount and count update:', count);

    // Cleanup on unmount or before next effect run
    return () => {
      console.log('Cleanup for count change');
    };
  }, [count]); // Runs on mount and when 'count' changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

- Component Did Mount: Use useEffect with an empty dependency array [].
- Component Did Update: Use useEffect with a dependency array containing the variables you want to track.
- Component Will Unmount: Use the cleanup function returned from useEffect.

useCallback is used to memoize functions to prevent unnecessary re-renders when the functions are passed as props.
